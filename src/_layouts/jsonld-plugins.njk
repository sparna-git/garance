
// registry of rendering plugins: { name: string, test: function(item): boolean }
const renderingRegistry = [
  {
    name: "renderWktLiteral",
    test: (item) => {
      if (!item) return false;
      const t = item["@type"] || item.type;
      if (!t) return false;
      if (Array.isArray(t)) return t.includes("http://www.opengis.net/ont/geosparql#wktLiteral");
      return t === "http://www.opengis.net/ont/geosparql#wktLiteral";
    },
  },
  {
    name: "renderRawLiteral",
    test: (item) => {
      // primitive values or objects that should be rendered raw
      return (
        typeof item === "string" ||
        typeof item === "number" ||
        typeof item === "boolean"
      );
    },
  },
  // add more entries here as needed
];


/**
 * Return the name of a rendering macro (string) able to render `item`,
 * or undefined if no suitable renderer is found.
 * The logic is driven by the renderingRegistry above and can be extended
 * by pushing new {name, test} entries into renderingRegistry.
 *
 * Example:
 *   getRenderingPlugin(someItem) -> "renderWktLiteral" | "renderRawLiteral" | undefined
 */
function getRenderingPlugin(item) {
  for (const entry of renderingRegistry) {
    try {
      if (entry.test(item)) return entry.name;
    } catch (err) {
      // ignore test errors and continue to next rule
    }
  }
  return undefined;
}

/**
 * Helper to register additional rendering plugins at runtime.
 * Usage:
 *   registerRenderingPlugin('renderFoo', item => item && item.type === 'foo:Bar');
 */
function registerRenderingPlugin(name, testFn) {
  if (typeof name !== "string" || typeof testFn !== "function") {
    throw new Error("registerRenderingPlugin requires (string, function)");
  }
  renderingRegistry.push({ name, test: testFn });
}

// export functions if using module exports (optional; keep consistent with file)
module.exports = Object.assign(module.exports || {}, {
  getRenderingPlugin,
  registerRenderingPlugin,
});


{% macro renderRawLiteral(item) %}
    {{ item | json }}
{% endmacro %}

